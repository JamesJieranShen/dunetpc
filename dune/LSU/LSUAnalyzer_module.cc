///////////////////////////////////////////////////////////////////////
// Class:       LSUAnalyzer
// Module Type: analyzer
// File:        LSUAnalyzer_module.cc
//
// Generated at Sat Feb 24 14:31:17 2018 by Justin Hugon using artmod
// from cetpkgsupport v1_13_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "nusimdata/SimulationBase/MCParticle.h"

#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/RecoBase/Track.h"

#include "art/Framework/Services/Optional/TFileService.h"
#include "larsim/MCCheater/BackTrackerService.h"

#include "dunetpc/dune/DuneObj/ProtoDUNEBeamEvent.h"
#include "dunetpc/dune/Protodune/Analysis/ProtoDUNEBeamlineUtils.h"
#include "dunetpc/dune/Protodune/Analysis/ProtoDUNEDataUtils.h"
#include "dunetpc/dune/Protodune/Analysis/ProtoDUNEPFParticleUtils.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TGraph.h"

#include <iostream>

class LSUAnalyzer;

class LSUAnalyzer : public art::EDAnalyzer {
public:
  explicit LSUAnalyzer(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  LSUAnalyzer(LSUAnalyzer const &) = delete;
  LSUAnalyzer(LSUAnalyzer &&) = delete;
  LSUAnalyzer & operator = (LSUAnalyzer const &) = delete;
  LSUAnalyzer & operator = (LSUAnalyzer &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Other functions.
  void beginJob() override;

private:

  // Declare member data here.

  protoana::ProtoDUNEBeamlineUtils fBeamlineUtils;
  double fNominalBeamMomentum;

  TH1F* fmcparticlePDG;
  TH1F* fmcparticleNparticles;
  TH2F* ftrackdEdxVResRange;

  TGraph* ftestGraph;
  size_t fiTestGraph;
};


LSUAnalyzer::LSUAnalyzer(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),
  fBeamlineUtils(p.get<fhicl::ParameterSet>("BeamlineUtils"))
{
  fNominalBeamMomentum = p.get<double>("NominalBeamMomentum");
}

void LSUAnalyzer::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  std::cout << "Event number: " << e.event() << std::endl;

  art::ServiceHandle<cheat::BackTrackerService> bt;

  // * MC truth information
  art::Handle< std::vector<simb::MCParticle> > mcparticleListHandle;
  std::vector<art::Ptr<simb::MCParticle> > mcparticleList;
  if ((!e.isRealData()) && e.getByLabel("largeant",mcparticleListHandle))
  {
    art::fill_ptr_vector(mcparticleList, mcparticleListHandle);
  }

  std::vector<art::Ptr<beam::ProtoDUNEBeamEvent>> beamVec;
  if(e.isRealData())
  {
    auto beamHand = e.getValidHandle<std::vector<beam::ProtoDUNEBeamEvent>>("beamevent");
    if(beamHand.isValid())
    {
      art::fill_ptr_vector(beamVec, beamHand);
    }
  }

  // reco track information
  art::Handle< std::vector<recob::Track> > trackListHandle;
  std::vector<art::Ptr<recob::Track> > trackList;
  if (e.getByLabel("pmtrack",trackListHandle))
  {
    art::fill_ptr_vector(trackList, trackListHandle);
  }

  // All reco hits
  art::Handle< std::vector<recob::Hit> > hitListHandle;
  std::vector<art::Ptr<recob::Hit> > hitList;
  if (e.getByLabel("linecluster",hitListHandle)) // Not sure if is "hitpdune", "linecluster" or "gaushit"
  {
    art::fill_ptr_vector(hitList, hitListHandle);
  }

  // One element for each track. Each one of those is a vector of calos for each wire plane
  const auto tracksCaloList = art::FindManyP<anab::Calorimetry>(trackList, e, "pmtrackcalo");
  const auto tracksHitList = art::FindManyP<recob::Hit>(trackList, e, "pmtrack");

  const size_t nParticles = mcparticleList.size();
  std::cout << "Number of MCParticle: " << nParticles << std::endl;
  fmcparticleNparticles->Fill(nParticles);
  for (size_t iParticle=0; iParticle < nParticles; iParticle++)
  {
    art::Ptr<simb::MCParticle> mcparticle = mcparticleList.at(iParticle);

    std::cout << "Particle: " << mcparticle->TrackId() 
              << " PDG: " << mcparticle->PdgCode() 
              << " Status: " << mcparticle->StatusCode() 
              << std::endl;
    fmcparticlePDG->Fill(mcparticle->PdgCode());
  } // for iParticle


  // Beamline info
  const bool PRINTBEAMEVENT=true;
  float TOF=-9999999; // ns
  short CKov0Status=-20;
  short CKov1Status=-20;
  bool oneBeamTrackAndMom=false;
  float beamMom=-9999999.; // GeV/c
  float beamTrackXFrontTPC=-9999999.; // cm
  float beamTrackYFrontTPC=-9999999.; // cm
  float beamTrackTheta=-9999999.; // rad
  float beamTrackPhi=-9999999.; // rad
  bool beamIsElectron;
  bool beamIsMuon;
  bool beamIsPion;
  bool beamIsKaon;
  bool beamIsProton;
  bool beamIsDeuteron;
  for(size_t iBeamEvent=0; iBeamEvent < beamVec.size(); iBeamEvent++)
  {
    beam::ProtoDUNEBeamEvent beamEvent = *(beamVec.at(iBeamEvent));
    TOF = beamEvent.GetTOF(); // ns
    CKov0Status = beamEvent.GetCKov0Status(); // if 1 then a fast particle
    CKov1Status = beamEvent.GetCKov1Status(); // if 1 then a fast particle
    if(PRINTBEAMEVENT)
    {
      std::cout << "LSUAnalyzer BeamEvent " << iBeamEvent << ": \n";
      std::cout << "  CTB Timestamp: " << beamEvent.GetCTBTimestamp() << "\n";
      std::cout << "  BI Trigger: " << beamEvent.GetBITrigger() << "\n";
      std::cout << "  Active Trigger: " << beamEvent.GetActiveTrigger() << "\n";
      std::cout << "  Is Trigger Matched: " << beamEvent.CheckIsMatched() << "\n";
      std::cout << "  TOF: " << TOF << "\n";
      std::cout << "  CKov0Status: " << CKov0Status << "\n";
      std::cout << "  CKov1Status: " << CKov1Status << "\n";
      //std::cout << "  CKov0Time: " << beamEvent.GetCKov0Time() << "\n";
      //std::cout << "  CKov1Time: " << beamEvent.GetCKov1Time() << "\n";
      std::cout << "  CKov0Pressure: " << beamEvent.GetCKov0Pressure() << "\n";
      std::cout << "  CKov1Pressure: " << beamEvent.GetCKov1Pressure() << "\n";
    }

    oneBeamTrackAndMom = beamEvent.GetNBeamTracks() == 1 && beamEvent.GetNRecoBeamMomenta() == 1;
    if (oneBeamTrackAndMom)
    {
      beamMom = beamEvent.GetRecoBeamMomentum(0); // GeV/c

      const recob::Track & track =  beamEvent.GetBeamTrack(0);
      beamTrackXFrontTPC = track.End().X();
      beamTrackYFrontTPC = track.End().Y();
      beamTrackTheta = track.EndDirection().Theta();
      beamTrackPhi = track.EndDirection().Phi();
      if(PRINTBEAMEVENT)
      {
        std::cout << "  Beam Momentum: "<< beamMom <<" GeV/c\n";
        std::cout << "  Beam Track: \n";
        std::cout << "    N Points:  " << track.NumberTrajectoryPoints() << "\n";
        std::cout << "    Start Pos: " << track.Vertex().X()
                                  << "  " << track.Vertex().Y()
                                  << "  " << track.Vertex().Z() << "\n";
        std::cout << "    End Pos:   " << beamTrackXFrontTPC
                                  << "  " << beamTrackYFrontTPC
                                  << "  " << track.End().Z() << "\n";
        std::cout << "    Start Theta: " << track.VertexDirection().Theta()*180/CLHEP::pi << " deg\n";
        std::cout << "    Start Phi:   " << track.VertexDirection().Phi()*180/CLHEP::pi << " deg\n";
        std::cout << "    End Theta:   " << beamTrackTheta*180/CLHEP::pi << " deg\n";
        std::cout << "    End Phi:     " << beamTrackPhi*180/CLHEP::pi << " deg\n";
      }
    }
    else if (PRINTBEAMEVENT)
    {
      std::cout << "  N beam tracks: " << beamEvent.GetNBeamTracks() << " N beam momenta: " << beamEvent.GetNRecoBeamMomenta() << "\n";
    }
    const auto& beamPIDs = fBeamlineUtils.GetPIDCandidates(beamEvent,fNominalBeamMomentum);
    beamIsElectron = beamPIDs.electron;
    beamIsMuon = beamPIDs.muon;
    beamIsPion = beamPIDs.pion;
    beamIsKaon = beamPIDs.kaon;
    beamIsProton = beamPIDs.proton;
    beamIsDeuteron = beamPIDs.deuteron; // not implemented I don't think
    if (PRINTBEAMEVENT)
    {
      std::cout << "  Official CERN PID: \n" 
                << "    beamIsElectron " << beamIsElectron << "\n"
                << "    beamIsMuon     " << beamIsMuon << "\n"
                << "    beamIsPion     " << beamIsPion << "\n"
                << "    beamIsKaon     " << beamIsKaon << "\n"
                << "    beamIsProton   " << beamIsProton << "\n"
                << "    beamIsDeuteron " << beamIsDeuteron << "\n";
    }
  } // for iBeamEvent

  std::cout << "Number of tracks: " << trackList.size() << std::endl;
  for (size_t iTrack=0; iTrack < trackList.size(); iTrack++)
  {
    art::Ptr<recob::Track> track = trackList.at(iTrack);

    float track_length = track->Length();
    std::cout << "Reco track length:  " << track_length << " cm " << std::endl;

    // calo info
    const auto calos = tracksCaloList.at(iTrack); // list of calos for this track, one for each wire plane
    for(const auto& calo: calos)
    {
      if(calo->PlaneID().Plane == 2) // I think plane 2 is the collection plane, planes 0 and 1 could be interesting, too.
      {
          float depositedEnergy = calo->KineticEnergy(); // amount of energy deposited by the track
          std::cout << "Track deposited energy: " << depositedEnergy << " MeV" << std::endl;

          // Iterates over each hit in the track in this wire plane
          for(size_t iRange = 0; iRange < calo->ResidualRange().size() && iRange < calo->dEdx().size(); iRange++)
          {
            // These are the reconstructed residual range and dE/dx
            float calo_residualRange = calo->ResidualRange().at(iRange);
            float calo_dEdx = calo->dEdx().at(iRange);
            std::cout << "Reco dE/dx:  " << calo_dEdx << " MeV/cm, residual range: " <<calo_residualRange<<" cm"<< std::endl;
            ftrackdEdxVResRange->Fill(calo_residualRange,calo_dEdx);
          }
        } // if plane == fCaloPlane
    } //for calo in caloVec

    // Match track to MCParticle information
    if(!e.isRealData())
    {
      const auto trackHits = tracksHitList.at(iTrack); // list of hits matched to this track
      // trackIDs, confusingly uniquely identify MCParticles, have nothing to do with reco tracks
      std::set<int> setOfTrackIDs = bt->GetSetOfTrackIds(trackHits); // all trackIDs for hits in this track
      std::set<int> thisTrackIDSet;
      int highestChargePurityTrackID=-999999;
      double highestChargePurity=-999999;
      for (const auto & trackID : setOfTrackIDs)
      {
          thisTrackIDSet.clear();
          thisTrackIDSet.insert(trackID);
          // what fraction of the track charge came from this particle
          float chargePurity = bt->HitChargeCollectionPurity(thisTrackIDSet,trackHits);
          // we want the particle with the largest fraction of the charge
          if (chargePurity > highestChargePurity)
          {
              highestChargePurity = chargePurity;
              highestChargePurityTrackID = trackID;
          }
      }
      if (highestChargePurity >= 0.)
      {
          thisTrackIDSet.clear();
          thisTrackIDSet.insert(highestChargePurityTrackID);
          // what fraction of the track hits came from this particle
          //float hitPurity = bt->HitCollectionPurity(thisTrackIDSet,trackHits);
          float chargePurity = highestChargePurity;
          // The amount of charge reconstructed in this track from this particle 
          // divided by the amount that could have possibly been reconstructed from this particle
          // (only for the collection plane)
          float chargeEfficiency = bt->HitChargeCollectionEfficiency(thisTrackIDSet,trackHits,hitList,geo::kZ);
          // The number of hits reconstructed in this track from this particle 
          // divided by the total number of hits from this particle (only for the collection plane)
          //float hitEfficiency = bt->HitCollectionEfficiency(thisTrackIDSet,trackHits,hitList,geo::kZ);

          std::cout << "Track: " << iTrack << " MC match charge purity: " << chargePurity << " charge efficiency: " << chargeEfficiency << std::endl;

          // Find the MCParticle corresponding to this trackID
          art::Ptr<simb::MCParticle> mcparticle;
          for(auto mcpart: mcparticleList)
          {
              if (mcpart->TrackId() == highestChargePurityTrackID)
              {
                  mcparticle = mcpart;
                  break;
              }
          }
          if (mcparticle.isNull())
          {
            std::cout<<"Warning: Couldn't find MCParticle for TrackID: "<<highestChargePurityTrackID<<" trying to find: " <<abs(highestChargePurityTrackID)<<"\n";
            for(auto mcpart: mcparticleList)
            {
                if (mcpart->TrackId() == abs(highestChargePurityTrackID))
                {
                    mcparticle = mcpart;
                    break;
                }
            }
            if (mcparticle.isNull())
            {
              std::string message = "Couldn't find MCParticle for TrackID: ";
              message.append(std::to_string(highestChargePurityTrackID));
              throw cet::exception("MCParticleNotFound",message);
            }
          } // if can't find MCParticle for highest Track ID

          // This is where you can do some analysis of the true particle and compare it to the reco
          int pdgid = mcparticle->PdgCode();
          std::cout << "Track: " << iTrack << " has PDG ID: " << pdgid << " and start momentum: "<<mcparticle->Momentum().Vect().Mag() << std::endl;
      }
      else
      {
          std::cout<<"Error: Couldn't find True Track ID for cluster "<<iTrack<<"\n";
      }
      
    }

  } // for iTrack

  // Just testing use of a graph

  ftestGraph->SetPoint(fiTestGraph,nParticles,trackList.size());
  fiTestGraph++;

  // Now for Pandora particle-flow (PF) Stuff
  protoana::ProtoDUNEPFParticleUtils pfPartUtils;
  const std::vector<const recob::PFParticle*> pfFromBeamSlice = pfPartUtils.GetPFParticlesFromBeamSlice(e,"pandora");
  std::cout << "Number of primary beam PFParticles (number of beam slices): " << pfFromBeamSlice.size() << std::endl;
  for(size_t iPF=0; iPF < pfFromBeamSlice.size(); iPF++)
  {
    const recob::PFParticle* pfBeamPart = pfFromBeamSlice.at(iPF);
    const auto& PFBeamPrimPDG = pfBeamPart->PdgCode();
    const auto& PFBeamPrimNDaughters = pfBeamPart->NumDaughters();
    std::cout << "Beam Primary PFParticle: "<< iPF 
                << " Reco PDG: " << PFBeamPrimPDG
                << " Number of daughter PFParticles: " << PFBeamPrimNDaughters
                << std::endl;
    const recob::Track* pfTrack = pfPartUtils.GetPFParticleTrack(*pfBeamPart, e, "pandora","pandoraTrack");
    if(pfTrack)
    {
      std::cout << "Beam Primary PFParticle is reconstructed as a track\n";
      // Now you can analyze this Pandora track just like you did the pmtrack earlier
    } // if pfTrack
    const recob::Shower* pfShower = pfPartUtils.GetPFParticleShower(*pfBeamPart, e, "pandora","pandoraShower");
    if(pfShower)
    {
      // Now you can analyze this shower. This is a reco electron or photon, check out recob::Shower on larsoft doxygen to see how to do it
      std::cout << "Beam Primary PFParticle is reconstructed as a shower\n";
    } // if pfShower
  } // for iPF

} // analyze function

void LSUAnalyzer::beginJob()
{
   art::ServiceHandle<art::TFileService> tfs;
   
   fmcparticlePDG = tfs->make<TH1F>("mcparticlePDG","Truth PDG ID",6000,-3000,3000);
   fmcparticleNparticles = tfs->make<TH1F>("mcparticleNparticles","True N Particles",1000,0,1000);

   ftrackdEdxVResRange = tfs->make<TH2F>("trackdEdxVResRange","Reco Track dE/dx [MeV/cm] v. Residual Range [cm]",100,0,30,100,0,50);
  
   ftestGraph = tfs->makeAndRegister<TGraph>("testGraph","");
   fiTestGraph = 0;
}

DEFINE_ART_MODULE(LSUAnalyzer)
