///////////////////////////////////////////////////////////////////////
// Class:       LSUAnalyzer
// Module Type: analyzer
// File:        LSUAnalyzer_module.cc
//
// Generated at Sat Feb 24 14:31:17 2018 by Justin Hugon using artmod
// from cetpkgsupport v1_13_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "nusimdata/SimulationBase/MCParticle.h"

#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/RecoBase/Track.h"

#include "art/Framework/Services/Optional/TFileService.h"
#include "larsim/MCCheater/BackTrackerService.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TGraph.h"

#include <iostream>

class LSUAnalyzer;

class LSUAnalyzer : public art::EDAnalyzer {
public:
  explicit LSUAnalyzer(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  LSUAnalyzer(LSUAnalyzer const &) = delete;
  LSUAnalyzer(LSUAnalyzer &&) = delete;
  LSUAnalyzer & operator = (LSUAnalyzer const &) = delete;
  LSUAnalyzer & operator = (LSUAnalyzer &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Other functions.
  void beginJob() override;

private:

  // Declare member data here.

  TH1F* fmcparticlePDG;
  TH1F* fmcparticleNparticles;
  TH2F* ftrackdEdxVResRange;

  TGraph* ftestGraph;
  size_t fiTestGraph;
};


LSUAnalyzer::LSUAnalyzer(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{}

void LSUAnalyzer::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  std::cout << "Event number: " << e.event() << std::endl;

  art::ServiceHandle<cheat::BackTrackerService> bt;

  // * MC truth information
  art::Handle< std::vector<simb::MCParticle> > mcparticleListHandle;
  std::vector<art::Ptr<simb::MCParticle> > mcparticleList;
  if (e.getByLabel("largeant",mcparticleListHandle))
  {
    art::fill_ptr_vector(mcparticleList, mcparticleListHandle);
  }

  // reco track information
  art::Handle< std::vector<recob::Track> > trackListHandle;
  std::vector<art::Ptr<recob::Track> > trackList;
  if (e.getByLabel("pmtrack",trackListHandle))
  {
    art::fill_ptr_vector(trackList, trackListHandle);
  }

  // All reco hits
  art::Handle< std::vector<recob::Hit> > hitListHandle;
  std::vector<art::Ptr<recob::Hit> > hitList;
  if (e.getByLabel("linecluster",hitListHandle)) // Not sure if is "hitpdune", "linecluster" or "gaushit"
  {
    art::fill_ptr_vector(hitList, hitListHandle);
  }

  // One element for each track. Each one of those is a vector of calos for each wire plane
  const auto tracksCaloList = art::FindManyP<anab::Calorimetry>(trackList, e, "pmtrackcalo");
  const auto tracksHitList = art::FindManyP<recob::Hit>(trackList, e, "pmtrack");

  const size_t nParticles = mcparticleList.size();
  std::cout << "Number of MCParticle: " << nParticles << std::endl;
  fmcparticleNparticles->Fill(nParticles);
  for (size_t iParticle=0; iParticle < nParticles; iParticle++)
  {
    art::Ptr<simb::MCParticle> mcparticle = mcparticleList.at(iParticle);

    std::cout << "Particle: " << mcparticle->TrackId() 
              << " PDG: " << mcparticle->PdgCode() 
              << " Status: " << mcparticle->StatusCode() 
              << std::endl;
    fmcparticlePDG->Fill(mcparticle->PdgCode());
  } // for iParticle

  std::cout << "Number of tracks: " << trackList.size() << std::endl;
  for (size_t iTrack=0; iTrack < trackList.size(); iTrack++)
  {
    art::Ptr<recob::Track> track = trackList.at(iTrack);

    float track_length = track->Length();
    std::cout << "Reco track length:  " << track_length << " cm " << std::endl;

    // calo info
    const auto calos = tracksCaloList.at(iTrack); // list of calos for this track, one for each wire plane
    for(const auto& calo: calos)
    {
      if(calo->PlaneID().Plane == 2) // I think plane 2 is the collection plane, planes 0 and 1 could be interesting, too.
      {
          float depositedEnergy = calo->KineticEnergy(); // amount of energy deposited by the track
          std::cout << "Track deposited energy: " << depositedEnergy << " MeV" << std::endl;

          // Iterates over each hit in the track in this wire plane
          for(size_t iRange = 0; iRange < calo->ResidualRange().size() && iRange < calo->dEdx().size(); iRange++)
          {
            // These are the reconstructed residual range and dE/dx
            float calo_residualRange = calo->ResidualRange().at(iRange);
            float calo_dEdx = calo->dEdx().at(iRange);
            std::cout << "Reco dE/dx:  " << calo_dEdx << " MeV/cm, residual range: " <<calo_residualRange<<" cm"<< std::endl;
            ftrackdEdxVResRange->Fill(calo_residualRange,calo_dEdx);
          }
        } // if plane == fCaloPlane
    } //for calo in caloVec

    // Match track to MCParticle information
    if(!e.isRealData())
    {
      const auto trackHits = tracksHitList.at(iTrack); // list of hits matched to this track
      // trackIDs, confusingly uniquely identify MCParticles, have nothing to do with reco tracks
      std::set<int> setOfTrackIDs = bt->GetSetOfTrackIds(trackHits); // all trackIDs for hits in this track
      std::set<int> thisTrackIDSet;
      int highestChargePurityTrackID=-999999;
      double highestChargePurity=-999999;
      for (const auto & trackID : setOfTrackIDs)
      {
          thisTrackIDSet.clear();
          thisTrackIDSet.insert(trackID);
          // what fraction of the track charge came from this particle
          float chargePurity = bt->HitChargeCollectionPurity(thisTrackIDSet,trackHits);
          // we want the particle with the largest fraction of the charge
          if (chargePurity > highestChargePurity)
          {
              highestChargePurity = chargePurity;
              highestChargePurityTrackID = trackID;
          }
      }
      if (highestChargePurity >= 0.)
      {
          thisTrackIDSet.clear();
          thisTrackIDSet.insert(highestChargePurityTrackID);
          // what fraction of the track hits came from this particle
          //float hitPurity = bt->HitCollectionPurity(thisTrackIDSet,trackHits);
          float chargePurity = highestChargePurity;
          // The amount of charge reconstructed in this track from this particle 
          // divided by the amount that could have possibly been reconstructed from this particle
          // (only for the collection plane)
          float chargeEfficiency = bt->HitChargeCollectionEfficiency(thisTrackIDSet,trackHits,hitList,geo::kZ);
          // The number of hits reconstructed in this track from this particle 
          // divided by the total number of hits from this particle (only for the collection plane)
          //float hitEfficiency = bt->HitCollectionEfficiency(thisTrackIDSet,trackHits,hitList,geo::kZ);

          std::cout << "Track: " << iTrack << " MC match charge purity: " << chargePurity << " charge efficiency: " << chargeEfficiency << std::endl;

          // Find the MCParticle corresponding to this trackID
          art::Ptr<simb::MCParticle> mcparticle;
          for(auto mcpart: mcparticleList)
          {
              if (mcpart->TrackId() == highestChargePurityTrackID)
              {
                  mcparticle = mcpart;
                  break;
              }
          }
          if (mcparticle.isNull())
          {
            std::cout<<"Warning: Couldn't find MCParticle for TrackID: "<<highestChargePurityTrackID<<" trying to find: " <<abs(highestChargePurityTrackID)<<"\n";
            for(auto mcpart: mcparticleList)
            {
                if (mcpart->TrackId() == abs(highestChargePurityTrackID))
                {
                    mcparticle = mcpart;
                    break;
                }
            }
            if (mcparticle.isNull())
            {
              std::string message = "Couldn't find MCParticle for TrackID: ";
              message.append(std::to_string(highestChargePurityTrackID));
              throw cet::exception("MCParticleNotFound",message);
            }
          } // if can't find MCParticle for highest Track ID

          // This is where you can do some analysis of the true particle and compare it to the reco
          int pdgid = mcparticle->PdgCode();
          std::cout << "Track: " << iTrack << " has PDG ID: " << pdgid << " and start momentum: "<<mcparticle->Momentum().Vect().Mag() << std::endl;
      }
      else
      {
          std::cout<<"Error: Couldn't find True Track ID for cluster "<<iTrack<<"\n";
      }
      
    }

  } // for iTrack

  ftestGraph->SetPoint(fiTestGraph,nParticles,trackList.size());
  fiTestGraph++;

} // analyze function

void LSUAnalyzer::beginJob()
{
   art::ServiceHandle<art::TFileService> tfs;
   
   fmcparticlePDG = tfs->make<TH1F>("mcparticlePDG","Truth PDG ID",6000,-3000,3000);
   fmcparticleNparticles = tfs->make<TH1F>("mcparticleNparticles","True N Particles",1000,0,1000);

   ftrackdEdxVResRange = tfs->make<TH2F>("trackdEdxVResRange","Reco Track dE/dx [MeV/cm] v. Residual Range [cm]",100,0,30,100,0,50);
  
   ftestGraph = tfs->makeAndRegister<TGraph>("testGraph","");
   fiTestGraph = 0;
}

DEFINE_ART_MODULE(LSUAnalyzer)
